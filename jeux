#include <iostream>
#include <cstdlib>
#include <conio.h>
#include <time.h>

using namespace std;

#define NROW 11
#define NCOL 21

void Affiche(char T[][NCOL])
{
    //on efface la console
    system("cls");

    //on affiche tout le tableau
    for(int x = 0; x < NROW; x++){
        for(int y = 0; y < NCOL; y++)
            cout << T[x][y];
        cout << endl;
    }
}

int main(int argc, char**argv){



    //allocation statique d'une matrice de caractères
    char T[NROW][NCOL];

    //on remplit avec ' ' partout
    //une instruction par niveau de boucle --> pas besoin de { }
    for (int i=0; i<NROW; i++)
        for (int j=0; j<NCOL; j++)
            T[i][j] =' ';


		srand(time(NULL));
		int	obstacle1_ligne = 0;
		obstacle1_ligne = rand()%(10-1) +1;
		//On génère la ligne de l'obstacle aléatoirement

		int obstacle1_colonne = 0;
		obstacle1_colonne = rand()%(20-1) +1;
		//On génère la colonne de l'obstacle aléatoirement

		T[obstacle1_ligne][obstacle1_colonne] ='O';
		//On affiche l'obstacle par un 'O'

    for (int i=0; i<NROW; i++)
            T[i][0] ='X';

		for (int i=0; i<NROW; i++)
            T[i][20] ='X';

		for (int i=0; i<NCOL; i++)
            T[0][i] ='X';

		for (int i=0; i<NCOL; i++)
            T[10][i] ='X';

    //On met des croix sur les côtés


    //initialisation position et valeur dans le tableau
    int row = 5, col=10;
    T[row][col] = 1;

    //on affiche une première fois
    Affiche (T);

    //on récupère la valeur unicode de la touche pressée tant qu'on n'apppuie pas sur ENTREE
    int touche = -1;
    while (touche != 13)    {

        touche = getch();
        //cout << touche <<endl;
        //system("pause");
        //préférer la structure switch si on a plus de 3 cas

        switch (touche) {

        case 75 : { // Appui sur la flèche gauche
							if(col==1){//Si on arrive sur un mur à gauche
							col=2;
												}

							if(col==obstacle1_colonne+1 && row==obstacle1_ligne){//Si on arrive sur l'obstacle
								col=col+1;
							}

            T[ row  ][ col-1 ] = 1;
            T[ row  ][ col ] = ' ';
            col--; // source de bug en cas de dépassement
            } break;

        case 77 : { // Appui sur la flèche droite
							if(col==19){ //Si on arrive sur un mur à droite
							col=18;
												}

							if(col==obstacle1_colonne-1 && row==obstacle1_ligne){//Si on arrive sur l'obstacle
								col=col-1;
							}

            T[ row  ][ col+1 ] = 1;
            T[ row  ][ col ] = ' ';
            col ++; // source de bug en cas de dépassement
           }break;

        case 72 : { //Appui sur la flèche haut
							if(row==1){//Si on arrive sur un mur en haut
							row=2;
												}

							if(col==obstacle1_colonne && row==obstacle1_ligne+1){//Si on arrive sur l'obstacle
								row=row+1;
							}

            T[ row - 1  ][ col ] = 1;
            T[ row  ][ col ] = ' ';
            row--;// source de bug en cas de dépassement
            } break;

        case 80 :{ //Appui sur la flèche du bas
							if(row==9){//Si on arrive sur un mur en bas
							row=8;
												}

							if(col==obstacle1_colonne && row==obstacle1_ligne-1){//Si on arrive sur l'obstacle
								row=row-1;
							}

            T[ row + 1  ][ col ] = 1;
            T[ row  ][ col ] = ' ';
            row++;// source de bug en cas de dépassement
            }break;

        }// fin switch

        Affiche(T);
    }// fin while

    system("PAUSE");
    return EXIT_SUCCESS;

}
